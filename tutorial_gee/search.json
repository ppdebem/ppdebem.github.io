[
  {
    "objectID": "topicos_especiais/frequencia_agua.html",
    "href": "topicos_especiais/frequencia_agua.html",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "",
    "text": "Utilizando todos os conhecimentos acumulados até agora, podemos dar prosseguimento para um estudo específico da frequência fluvial na região amazônica. Para isso, utilizaremos imagens de radar da coleção Sentinel 1 presente na plataforma Earth Engine. Essa coleção é definida pelo código COPERNICUS/S1_GRD. Por questão de consistencia de dados, também precisaremos aplicar alguns filtros de parâmetros específicos como será visto no código a seguir:\n// Ponto para delimitação da área de trabalho\nvar area_teste = ee.Geometry.Point([-57.1892, -2.5647]);\n\n// Definição da coleção\nvar sentinel = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .filter(ee.Filter.eq('instrumentMode', \"IW\"))\n  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n  .filter(ee.Filter.eq('platform_number', 'A'))\n  .filterDate('2017-01-01', '2022-12-31')\n  .filterBounds(area_teste);\nOs primeiros dois filtros aplicados (ee.Filter.listContains) garantem que todas as imagens da coleção contenham as bandas de polarização VH e VV já que em alguns casos imagens podem conter apenas uma delas. Os três filtros seguintes (ee.Filter.eq) delimitam características específicas desejadas, sendo elas o modo interferométrico do sensor (IW), de órbita descendente (DESCENDING), da plataforma Sentinel 1A. Por fim, limitamos as imagens para datas entre 2017 e 2022, num ponto específico da região."
  },
  {
    "objectID": "topicos_especiais/frequencia_agua.html#definindo-a-coleção",
    "href": "topicos_especiais/frequencia_agua.html#definindo-a-coleção",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "",
    "text": "Utilizando todos os conhecimentos acumulados até agora, podemos dar prosseguimento para um estudo específico da frequência fluvial na região amazônica. Para isso, utilizaremos imagens de radar da coleção Sentinel 1 presente na plataforma Earth Engine. Essa coleção é definida pelo código COPERNICUS/S1_GRD. Por questão de consistencia de dados, também precisaremos aplicar alguns filtros de parâmetros específicos como será visto no código a seguir:\n// Ponto para delimitação da área de trabalho\nvar area_teste = ee.Geometry.Point([-57.1892, -2.5647]);\n\n// Definição da coleção\nvar sentinel = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .filter(ee.Filter.eq('instrumentMode', \"IW\"))\n  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))\n  .filter(ee.Filter.eq('platform_number', 'A'))\n  .filterDate('2017-01-01', '2022-12-31')\n  .filterBounds(area_teste);\nOs primeiros dois filtros aplicados (ee.Filter.listContains) garantem que todas as imagens da coleção contenham as bandas de polarização VH e VV já que em alguns casos imagens podem conter apenas uma delas. Os três filtros seguintes (ee.Filter.eq) delimitam características específicas desejadas, sendo elas o modo interferométrico do sensor (IW), de órbita descendente (DESCENDING), da plataforma Sentinel 1A. Por fim, limitamos as imagens para datas entre 2017 e 2022, num ponto específico da região."
  },
  {
    "objectID": "topicos_especiais/frequencia_agua.html#pré-processamento",
    "href": "topicos_especiais/frequencia_agua.html#pré-processamento",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "Pré processamento",
    "text": "Pré processamento\nEm seguida, precisamos realizar dois processos que podem ser inseridos na mesma função:\n\nFiltrar valores extremamente baixos não representativos característicos do sensor SAR Sentinel 1 que aparecem nas bordas das imagens;\nExtrair as máscaras d’água com base nos valores das bandas VV e VH. Superfícies d’água são de fácil identificação usando essas bandas pois geralmente apresentam valores muito baixos, abaixo de -14 e -20 para as bandas VV e VH respectivamente.\n\nA função, portanto, é a seguinte:\n// Função para corrigir as imagens e extrair máscaras\nfunction extrairMascara(im) {\n    // Remover valores muito baixos\n    var edge = im.lt(-30.0);\n    var mascara = im.mask().and(edge.not());\n    im = im.updateMask(mascara);\n    \n    // Extrair máscara d'água\n    var vv = im.select('VV');\n    var vh = im.select('VH');\n    var mascaraDagua = vh.lt(-20).and(vv.lt(-14)).copyProperties(im, ['system:time_start']);\n    return mascaraDagua;\n  }\n  \nvar mascaras = sentinel.map(extrairMascara);"
  },
  {
    "objectID": "topicos_especiais/frequencia_agua.html#primeiro-caso-frequência-média-de-água",
    "href": "topicos_especiais/frequencia_agua.html#primeiro-caso-frequência-média-de-água",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "Primeiro caso: frequência média de água",
    "text": "Primeiro caso: frequência média de água\nDe posse das máscaras d’água de toda nossa coleção, calcular a frequência média da ocorrência dos corpos d’água é simples. Basta utilizar a função de redução mean. Para melhorar a visualização, estaremos também utilizando uma paleta de cores customizada.\n// Frequência média entre 2017 e 2022\nvar freqMedia = mascaras.mean();\n\nvar visMedia = {\n  min:0,\n  max:1,\n  palette:['white', 'skyblue', 'slateblue']\n}\n\nMap.centerObject(area_teste, 11);\nMap.addLayer(freqMedia, visMedia, \"Frequencia Média 2017-2022\");\nOs valores neste objeto vão de 0 a 1, representando a frequência média em que um pixel d’água foi detectado. Visualmente, quanto mais azulado o ponto, maior a frequência de água.\n\n\n\n\n\nUsando esse mesmo produto, podemos extrair uma máscara de corpos d’água em função da frequência de sua ocorrência. Por exemplo, para extrairmos uma máscara onde a água esteve presente em 90% das imagens, podemos usar o seguinte código:\n// Máscara de 90% de frequência d'água\nvar freq90 = freqMedia.gt(0.9).selfMask();\n\nMap.addLayer(freq90, {palette:['blue']}, \"90% de frequência\");"
  },
  {
    "objectID": "topicos_especiais/frequencia_agua.html#detalhando-a-frequência-média",
    "href": "topicos_especiais/frequencia_agua.html#detalhando-a-frequência-média",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "Detalhando a frequência média",
    "text": "Detalhando a frequência média\nApesar de muito úteis, o problema dos dois produtos anteriores é que somente com eles é impossível determinar a dinâmica de variação de frequência ao longo do tempo. Para fazer essa análise, podemos dividir nossa coleção em períodos distintos para observar a mudança nas frequências médias.\n\nFrequência trienal\nEm um primeiro exemplo, podemos dividir a coleção de máscaras pela metade em dois períodos:\n// Divisão em triênios\nvar t1 = mascaras.filterDate('2017-01-01', '2019-12-31').mean();\nvar t2 = mascaras.filterDate('2020-01-01', '2022-12-31').mean();\nAgora que temos as frequências médias nestes dois períodos, a análise mais simples que podemos fazer é a de diferença das médias:\nvar difTrienal = t2.subtract(t1);\n\nvar visTrienal = {\n  min:-1,\n  max:1,\n  palette:['red', 'whitesmoke', 'limegreen']\n};\n\nMap.addLayer(difTrienal, visTrienal, \"Diferença entre triênios\");\nNote que agora temos mais detalhes da dinâmica de frequência. Valores avermelhados indicam que a presença de água foi mais frequente no primeiro período (corpos mais velhos que desapareceram), enquanto valores verdes indicam maior frequência no segundo período (corpos mais novos que surgiram). Valores brancos indicam pouca ou nenhuma mudança entre os dois períodos.\n\n\n\n\n\n\n\nFrequência bienal\nPodemos detalhar essa dinâmica um pouco mais dividindo nossa coleção em biênios:\n// Divisão em biênios\nvar b1 = mascaras.filterDate('2017-01-01', '2018-12-31').mean().rename('b1');\nvar b2 = mascaras.filterDate('2019-01-01', '2020-12-31').mean().rename('b2');\nvar b3 = mascaras.filterDate('2021-01-01', '2022-12-31').mean().rename('b3');\nPara integrar esses biênios, podemos empilhá-los em uma única imagem como se cada um fosse uma banda diferente:\nvar difBienal = b1.addBands(b2).addBands(b3);\n\nvar visBienal = {\n  min:0.02,\n  max:0.98,\n  bands:['b1', 'b3', 'b2']\n};\n\nMap.addLayer(difBienal, visBienal, \"Mudança bienal de frequências\");\nObserve que agora há uma distinção maior na dinâmica de frequência. Além das cores vermelha e verde que representam maiores frequências velhas e novas respectivamente, temos também as cores magenta e ciano que representam a frequência nos períodos de transição entre o primeiro e segundo biênio; e o segundo e terceiro biênio respectivamente."
  },
  {
    "objectID": "topicos_especiais/frequencia_agua.html#conclusão",
    "href": "topicos_especiais/frequencia_agua.html#conclusão",
    "title": "Análise de frequência fluvial na Amazônia",
    "section": "Conclusão",
    "text": "Conclusão\nEsta análise é simples e de grande utilidade por permitir observar o comportamento dos corpos d’água na Amazônia em diferentes níveis temporais. Sua rápida aplicação é possível graças à plataforma Earth Engine que permite que uma quantidade grande de imagens sejam processadas simultaneamente e de maneira quase imediata. O código completo construído nesse guia pode ser encontrado neste link."
  },
  {
    "objectID": "intermediarios/0202mascaras.html",
    "href": "intermediarios/0202mascaras.html",
    "title": "Filtros de pixels e máscaras",
    "section": "",
    "text": "Máscaras são extremamente uteis para isolar ou evidenciar certas feições em imagens de satélite. Elas podem ser feitas manualmente ou através de filtros lógicos em função de valores de pixels. Nesta seção, exploraremos o segundo caso."
  },
  {
    "objectID": "intermediarios/0202mascaras.html#criação-de-uma-máscara-através-de-filtros",
    "href": "intermediarios/0202mascaras.html#criação-de-uma-máscara-através-de-filtros",
    "title": "Filtros de pixels e máscaras",
    "section": "Criação de uma máscara através de filtros",
    "text": "Criação de uma máscara através de filtros\nDo mesmo modo como atributos internos (metadados) de uma imagem podem ser filtrados utilizando as funções ee.Filter, as imagens (não coleções) podem ser filtradas em função dos valores de seus pixels utilizando funções internas das imagens como eq (igual), gt (maior que) e lt (menor que).\nComo exemplo, podemos tentar extrair uma máscara de corpos d’água usando uma imagem Landsat. Para isto, vamos primeiramente isolar a banda correspondente ao infravermelho próximo por caracterizar bem os corpos d’água.\nvar paranoa = ee.Geometry.Point([-47.8243, -15.7801]);\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(paranoa)\n              .filterDate(\"2021-07-01\", \"2021-07-31\")\n              .first();\n\nvar nir = landsat.select('SR_B5').multiply(2.75e-05).add(-0.2);\n\nMap.centerObject(paranoa, 12); // O valor 12 nesta função determina o \"zoom\" inicial desejado, quanto maior o valor, maior o \"zoom\" \nMap.addLayer(nir, {min:0, max:1}, 'Banda NIR');\nApós exibir a imagem, clique na aba Inspector do painel do console, clique dentro da região do Lago Paranoá e observe os valores apresentados na aba Inspector. Você irá notar que sempre são valores muito baixos.\n\n\n\n\n\nEste é o comportamento característico da banda do infravermelho próximo em corpos d’água. Há pouca reflexão da energia eletromagnética nesta faixa, portando os sensores representam estes objetos com valores muito baixos de reflectância.\nPortanto, podemos usar essa característica para tentar isolar os corpos d’água nestas imagens. Vamos criar uma máscara que admita somente valores de reflectância abaixo de 0.05:\nvar paranoa = ee.Geometry.Point([-47.8243, -15.7801]);\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(paranoa)\n              .filterDate(\"2021-07-01\", \"2021-07-31\")\n              .first();\n\nvar nir = landsat.select('SR_B5').multiply(2.75e-05).add(-0.2);\n\nvar mascaraAgua = nir.lt(0.05)\n\nMap.centerObject(paranoa, 12); \nMap.addLayer(nir, {min:0, max:1}, 'Banda NIR');\nMap.addLayer(mascaraAgua, {palette:['black', 'blue']} ,'Máscara Água');\n\n\n\n\n\nObserve que agora temos uma camada com dois valores:\n\n0 para regiões de reflectância superior a 0.05 (regiões sem água)\n1 para regiões de reflectância inferior a 0.05 (regiões com água)\n\nPara fim de melhorar a visualização, podemos excluir os valores que não são de nosso interesse utilizando essa mascara em si mesma com a função selfMask:\nvar mascaraAgua = nir.lt(0.05).selfMask();\n\nMap.centerObject(paranoa, 12); \nMap.addLayer(nir, {min:0, max:1}, 'Banda NIR');\nMap.addLayer(mascaraAgua, {palette:['blue']}, 'Máscara Água');"
  },
  {
    "objectID": "intermediarios/0202mascaras.html#combinação-de-máscaras",
    "href": "intermediarios/0202mascaras.html#combinação-de-máscaras",
    "title": "Filtros de pixels e máscaras",
    "section": "Combinação de máscaras",
    "text": "Combinação de máscaras\nPoderíamos ainda refinar essa máscara utilizando um segundo filtro, usando, por exemplo, valores de NDVI. Corpos d’água geralmente apresentam valores negativos de NDVI, e portanto podem ser isolados.\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar ndvi = calcular_ndvi(landsat);\n\nMap.addLayer(ndvi, {min:-0.05, max:0.5, palette:['red','white','green']}, \"NDVI\")\n\n\n\n\n\nPara usar tanto os valores de NIR quanto os de NDVI para criação da máscara , podemos usar funções lógicas como and (ambas as condições) e or (uma ou a outra condição):\nvar mascaraAgua = nir.lt(0.05).and(ndvi.lt(0)).selfMask();\n\nMap.addLayer(mascaraAgua, {palette:['blue']} ,'Máscara Água');\nObserve que agora obtemos uma máscara com duplo grau de certeza da presença de corpos d’água, porém isso também significa que talvez estejamos omitindo pixels que representam água mas não atingiram um ou o outro critério de separação.\nPergunta: o que aconteceria se utilizássemos a função or no lugar da função and?\n\n\n\n\n\n\nResposta\n\n\n\n\n\nNesse caso seriam permitidos pixels com reflectância menor que 0.05 OU NDVI menor que 0. Em contraste com a função and, isto poderia gerar um problema diferente, neste caso com erros de comissão."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução",
    "section": "",
    "text": "Esta página foi criada com a intenção de fornecer um guia de utilização da plataforma Google Earth Engine (GEE) para auxiliar as pesquisas realizadas no Laboratório de Sistemas de Informação Espacial (LSIE) da Universidade de Brasília.\nOs tutoriais estão divididos em diferentes níveis de utilização e podem ser acessados através da barra de navegação no lado esquerdo da página.\nOs guias são apresentados utilizando o ambiente web da plataforma Earth Engine como base e portanto a linguagem de programação utilizada será Javascript. A plataforma também pode ser utilizada através da linguagem Python, porém isto não faz parte do escopo desta página.\nVale lembrar ainda que este guia é tem caráter básico e específico e cobrirá uma fração das funcionalidades da plataforma Earth Engine. Uma variedade maior de guias em inglês elaborados pela própria Google se encontra disponível neste link."
  },
  {
    "objectID": "index.html#sobre-esta-página",
    "href": "index.html#sobre-esta-página",
    "title": "Introdução",
    "section": "",
    "text": "Esta página foi criada com a intenção de fornecer um guia de utilização da plataforma Google Earth Engine (GEE) para auxiliar as pesquisas realizadas no Laboratório de Sistemas de Informação Espacial (LSIE) da Universidade de Brasília.\nOs tutoriais estão divididos em diferentes níveis de utilização e podem ser acessados através da barra de navegação no lado esquerdo da página.\nOs guias são apresentados utilizando o ambiente web da plataforma Earth Engine como base e portanto a linguagem de programação utilizada será Javascript. A plataforma também pode ser utilizada através da linguagem Python, porém isto não faz parte do escopo desta página.\nVale lembrar ainda que este guia é tem caráter básico e específico e cobrirá uma fração das funcionalidades da plataforma Earth Engine. Uma variedade maior de guias em inglês elaborados pela própria Google se encontra disponível neste link."
  },
  {
    "objectID": "index.html#sobre-a-plataforma-google-earth-engine",
    "href": "index.html#sobre-a-plataforma-google-earth-engine",
    "title": "Introdução",
    "section": "Sobre a plataforma Google Earth Engine",
    "text": "Sobre a plataforma Google Earth Engine\nA plataforma GEE contém um catalogo extenso de imagens de satélite e outros produtos de sensoriamento remoto e sistemas de informações geográficas. Ela permite acesso para a visualização e processamento destes estes dados em nuvem para fins comerciais e não comerciais como pesquisas científicas e educação.\nA principal vantagem oferecida pela sua utilização é o rápido acesso a este enorme catalogo de imagens, permitindo a rápida execução de processamentos, análises e coleta de dados em toda a extensão da terra."
  },
  {
    "objectID": "index.html#limitações",
    "href": "index.html#limitações",
    "title": "Introdução",
    "section": "Limitações",
    "text": "Limitações\nApesar da ampla disponibilidade de dados, a plataforma possui limites de memória e processamento a depender da quantidade de imagens e do nível de complexidade do processamento dos dados. Recomenda-se que os usuários utilizem uma metodologia eficiente com isto em mente. Geralmente, a filtragem de imagens por data e e local evita que estes limites sejam atingidos."
  },
  {
    "objectID": "index.html#pré-requisitos",
    "href": "index.html#pré-requisitos",
    "title": "Introdução",
    "section": "Pré-requisitos",
    "text": "Pré-requisitos\nFamiliaridade básica com qualquer linguagem de programação é recomendada porém não estritamente necessária.\nPara utilizar a plataforma você precisará primeiramente de uma conta Google. Imagens produzidas na plataforma poderão ser exportadas para o Google Drive associado a esta conta.\nEm seguida, é necessário se registrar na plataforma através deste link.\nApós o registro, você poderá então começar a utilizar a plataforma através do link https://code.earthengine.google.com/."
  },
  {
    "objectID": "index.html#contato",
    "href": "index.html#contato",
    "title": "Introdução",
    "section": "Contato",
    "text": "Contato\nEm caso de dúvidas, críticas ou sugestões, entre em contato através do meu e-mail: pablodebem@gmail.com."
  },
  {
    "objectID": "basicos/0108exercicio2.html",
    "href": "basicos/0108exercicio2.html",
    "title": "Exercício 2 - Cálculo do NDWI",
    "section": "",
    "text": "O Índice de Diferença Normalizada da Água (NDWI) é importante para o monitoramento de corpos d’água, e sua fórmula é a seguinte:\n\\[\n\\text{NDWI} = \\frac{(\\text{Verde} - \\text{Infravermelho Próximo})}{(\\text{Verde} + \\text{Infravermelho Próximo)}}\n\\]\nDito isso, calcule e plote a imagem correspondente ao NDWI médio do mês de julho de 2021 usando imagens Landsat 8 assim como calculamos o NDVI nas seções anteriores. Adicionalmente, ajuste os valores mínimos e máximos da visualização e tente considerar uma paleta de cores apropriada para esta visualização tendo em mente que se trata de uma análise de corpos d’água.\n\n\n\n\n\n\nResposta\n\n\n\n\n\nAs bandas verde e NIR das imagens Landsat 8 são nomeadas SR_B3 e SR_B5 respectivamente, portanto podemos calcular o NDWI da seguinte maneira:\nfunction calcular_ndwi(imagem){\n  imagem = imagem.multiply(2.75e-05).add(-0.2);\n  var green = imagem.select('SR_B3');\n  var nir = imagem.select('SR_B5');\n  var ndwi = green.subtract(nir).divide(green.add(nir));\n  return ndwi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndwi_julho = landsat.map(calcular_ndwi);\n\nvar ndwi_julho_media = ndwi_julho.mean();\n\nvar visNDWI = {\n  min: -1,\n  max: 1,\n  palette: ['gray', 'white', 'blue']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndwi_julho_media, visNDWI, 'NDWI Médio em Julho');"
  },
  {
    "objectID": "basicos/0108exercicio2.html#exercício-2a",
    "href": "basicos/0108exercicio2.html#exercício-2a",
    "title": "Exercício 2 - Cálculo do NDWI",
    "section": "",
    "text": "O Índice de Diferença Normalizada da Água (NDWI) é importante para o monitoramento de corpos d’água, e sua fórmula é a seguinte:\n\\[\n\\text{NDWI} = \\frac{(\\text{Verde} - \\text{Infravermelho Próximo})}{(\\text{Verde} + \\text{Infravermelho Próximo)}}\n\\]\nDito isso, calcule e plote a imagem correspondente ao NDWI médio do mês de julho de 2021 usando imagens Landsat 8 assim como calculamos o NDVI nas seções anteriores. Adicionalmente, ajuste os valores mínimos e máximos da visualização e tente considerar uma paleta de cores apropriada para esta visualização tendo em mente que se trata de uma análise de corpos d’água.\n\n\n\n\n\n\nResposta\n\n\n\n\n\nAs bandas verde e NIR das imagens Landsat 8 são nomeadas SR_B3 e SR_B5 respectivamente, portanto podemos calcular o NDWI da seguinte maneira:\nfunction calcular_ndwi(imagem){\n  imagem = imagem.multiply(2.75e-05).add(-0.2);\n  var green = imagem.select('SR_B3');\n  var nir = imagem.select('SR_B5');\n  var ndwi = green.subtract(nir).divide(green.add(nir));\n  return ndwi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndwi_julho = landsat.map(calcular_ndwi);\n\nvar ndwi_julho_media = ndwi_julho.mean();\n\nvar visNDWI = {\n  min: -1,\n  max: 1,\n  palette: ['gray', 'white', 'blue']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndwi_julho_media, visNDWI, 'NDWI Médio em Julho');"
  },
  {
    "objectID": "basicos/0106map.html",
    "href": "basicos/0106map.html",
    "title": "A função map",
    "section": "",
    "text": "Suponha que existe a necessidade de aplicar uma função não só a uma ou duas imagens mas a toda uma coleção. Neste caso, temos como opção o uso da função map. Esta função pode ser aplicada somente a coleções ou listas de imagens, podendo ser aplicada em uma sequência de funções utilizando o ponto (.).\nUtilizando os exemplos das seções anteriores, suponha que precisamos de imagens NDVI em um mês inteiro. Começamos definindo as funções corrigir_valores e calcular_ndvi e nossa coleção:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\nprint(landsat)\n\n\n\n\n\nEm seguida podemos utilizar a função map para aplicar as funções para corrigir os valores e calcular o NDVI a todas as imagens da coleção:\n\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\nObserve que isto retornou uma nova coleção com o mesmo número de imagens, porém com imagens NDVI de apenas uma banda:\n\n\n\n\n\nA função map será uma ferramenta essencial para diversos tipos de análises utilizando a plataforma Earth Engine.\n\n\n\n\n\n\nAtenção\n\n\n\nNão confunda a função map com funções responsáveis pela plotagem de objetos no mapa (Map.addLayer, etc)."
  },
  {
    "objectID": "basicos/0104operações.html",
    "href": "basicos/0104operações.html",
    "title": "Operações entre bandas",
    "section": "",
    "text": "Já sabemos como filtrar as bandas em uma coleção de imagens. Para isola-las o processo é similar:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar img = landsat.first().multiply(2.75e-05).add(-0.2); // Escolhendo somente a primeira imagem da coleção e corrigindo os valores\n\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\nNote que desta vez usamos a função select depois de selecionar a primeira imagem da coleção. Essa função funciona tanto em coleções quanto imagens isoladas."
  },
  {
    "objectID": "basicos/0104operações.html#isolando-bandas",
    "href": "basicos/0104operações.html#isolando-bandas",
    "title": "Operações entre bandas",
    "section": "",
    "text": "Já sabemos como filtrar as bandas em uma coleção de imagens. Para isola-las o processo é similar:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar img = landsat.first().multiply(2.75e-05).add(-0.2); // Escolhendo somente a primeira imagem da coleção e corrigindo os valores\n\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\nNote que desta vez usamos a função select depois de selecionar a primeira imagem da coleção. Essa função funciona tanto em coleções quanto imagens isoladas."
  },
  {
    "objectID": "basicos/0104operações.html#matemática-de-imagens",
    "href": "basicos/0104operações.html#matemática-de-imagens",
    "title": "Operações entre bandas",
    "section": "Matemática de imagens",
    "text": "Matemática de imagens\nJá usamos as funções multiply e add para multiplicar e somar valores fixos às imagens. Estas funções matemáticas também podem ser usadas para multiplicar e somar bandas inteiras. Tomemos a função de cálculo do NDVI como exemplo:\n\\[\nNDVI = \\frac{(NIR - RED)}{(NIR + RED)}\n\\]\nTraduzindo a função para javascript com as variáveis criadas anteriormente, temos o seguinte:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar img = landsat.first().multiply(2.75e-05).add(-0.2); // Escolhendo somente a primeira imagem da coleção e corrigindo os valores\n\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red))"
  },
  {
    "objectID": "basicos/0104operações.html#adicionando-a-imagem-ao-mapa",
    "href": "basicos/0104operações.html#adicionando-a-imagem-ao-mapa",
    "title": "Operações entre bandas",
    "section": "Adicionando a imagem ao mapa",
    "text": "Adicionando a imagem ao mapa\nJuntando o que aprendemos nos passos anteriores podemos agora adicionar tanto a imagem RGB quanto a imagem NDVI calculada. Varias imagens podem ser adicionadas ao mesmo mapa usando a função Map.addLayer que já é conhecida. Observe que por ser uma imagem de apenas uma banda a imagem NDVI requer o parâmetro palette entre seus parâmetros de visualização. Neste caso usamos uma lista com os valores de “vermelho”, “amarelo” e “verde” que correspondem a valores baixos, medianos e altos respectivamente.\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar img = landsat.first().multiply(2.75e-05).add(-0.2); // Escolhendo somente a primeira imagem da coleção\n\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red))\n\nvar visRGB = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 0.01,\n  max: 0.2,\n};\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(img, visRGB, 'Imagem RGB');\nMap.addLayer(ndvi, visNDVI, 'NDVI');\nPodemos escolher quais imagens queremos visualizar usando as opções de Layer no canto superior direito do painel com o mapa.\n\n\n\n\n\n\n\n\n\n\n\nPaletas de cores para visualização\n\n\n\nPaletas de cores são um elemento importante da visualização de imagens na plataforma Earth Engine. Elas são essencialmente listas com uma ordem de cores a ser seguida em função dos valores mínimos e máximos de uma visualização.\nNo exemplo acima, onde temos o código:\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\nestamos definindo que os valores mais baixos (mínimo 0) devem aparecer na cor vermelha, valores intermediários na cor branca e valores altos na cor verde (máximo 1).\nAs cores, em javascript, podem ser definidas com base em alguns nomes pré-definidos (exemplos neste link) ou em função de códigos hexadecimais de cores (e.g. vermelho = #ff6347).\nO número de cores que devem ser definidas na paleta de cores depende do tipo da informação. Dados discretos (de classes) precisam de no mínimo (e no máximo) uma cor por classe, enquanto dados contínuos precisam de no mínimo duas cores e não têm número máximo definido. Visualizações de dados contínuos utilizarão as cores de maneira gradual em função do mínimo e máximo."
  },
  {
    "objectID": "basicos/0103exibição.html",
    "href": "basicos/0103exibição.html",
    "title": "Exibição de imagens",
    "section": "",
    "text": "Para fim de exemplo, vamos selecionar somente as bandas RGB da coleção filtrada utilizando a função select que aceita um nome de banda ou uma lista de nomes:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar landsatRGB = landsat.select(['SR_B2', 'SR_B3', 'SR_B4']);\n\n\n\n\n\n\nListas\n\n\n\n\n\nEm javascript listas são denotadas por nomes ou objetos entre colchetes ([ ]), por exemplo:\nvar bandas_rgb = ['SR_B2', 'SR_B3', 'SR_B4']\nvar paleta_cores = ['red', 'blue', 'green']"
  },
  {
    "objectID": "basicos/0103exibição.html#seleção-de-bandas",
    "href": "basicos/0103exibição.html#seleção-de-bandas",
    "title": "Exibição de imagens",
    "section": "",
    "text": "Para fim de exemplo, vamos selecionar somente as bandas RGB da coleção filtrada utilizando a função select que aceita um nome de banda ou uma lista de nomes:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar landsatRGB = landsat.select(['SR_B2', 'SR_B3', 'SR_B4']);\n\n\n\n\n\n\nListas\n\n\n\n\n\nEm javascript listas são denotadas por nomes ou objetos entre colchetes ([ ]), por exemplo:\nvar bandas_rgb = ['SR_B2', 'SR_B3', 'SR_B4']\nvar paleta_cores = ['red', 'blue', 'green']"
  },
  {
    "objectID": "basicos/0103exibição.html#extraindo-a-primeira-imagem-da-coleção",
    "href": "basicos/0103exibição.html#extraindo-a-primeira-imagem-da-coleção",
    "title": "Exibição de imagens",
    "section": "Extraindo a primeira imagem da coleção",
    "text": "Extraindo a primeira imagem da coleção\nNão precisamos das duas imagens do mês, então podemos selecionar a primeira delas usando a função first sem nenhum parâmetro:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar landsatRGB = landsat.select(['SR_B2', 'SR_B3', 'SR_B4']);\n\nvar landsat_primeira_julho = landsatRGB.first();"
  },
  {
    "objectID": "basicos/0103exibição.html#ajustando-os-valores-das-imagens",
    "href": "basicos/0103exibição.html#ajustando-os-valores-das-imagens",
    "title": "Exibição de imagens",
    "section": "Ajustando os valores das imagens",
    "text": "Ajustando os valores das imagens\nComo visto na seção anterior, as imagens não apresentam seus valores reais. Sabemos que para as imagens Landsat 8, as bandas 1 a 7 tem um valor de scale igual a 2.75 \\(\\times\\) 105 (ou 2.75e-05) e um offset de -0.2, então Podemos então ajustar os valores através das funções de multiplicação e adição multiply e add:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar landsatRGB = landsat.select(['SR_B2', 'SR_B3', 'SR_B4']);\n\nvar landsat_primeira_julho = landsatRGB.first().multiply(0.0000275).add(-0.2);\n// Observação: notações cientificas podem ser usadas, isto é, 0.0000275 = 2.75e-05 \n\n\n\n\n\n\nOperações matemáticas em imagens\n\n\n\nÉ importante mencionar que sempre que for necessário realizar operações matemáticas a imagens isto deve ser feito utilizando as funções especificas da plataforma Earth Engine tais como multiply, add e divide:\n// Errado\nvar imagem_multiplicada = imagem * 2\n\n// Correto\nvar imagem_multiplicada = imagem.multiply(2)\nOs meios tradicionais de realização de operações são reservados para objetos simples como números."
  },
  {
    "objectID": "basicos/0103exibição.html#definição-dos-parâmetros-de-visualização",
    "href": "basicos/0103exibição.html#definição-dos-parâmetros-de-visualização",
    "title": "Exibição de imagens",
    "section": "Definição dos parâmetros de visualização",
    "text": "Definição dos parâmetros de visualização\nAntes de exibir a imagem, precisamos definir os parâmetros de visualização tais como as bandas a serem usadas na composição RGB e seus valores mínimos e máximos:\nvar visualizacao = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'], // Sequencia de bandas RGB\n  min: 0.01, // Valores mínimo e máximo associados à intensidade das cores  \n  max: 0.2, //\n};\n\n\n\n\n\n\nDicionários\n\n\n\n\n\nEm javascript dicionários são denotados por pares variável: valor separados por vírgula e inseridos entre chaves ({ }), como observado na variável visualizacao no bloco anterior.\nDicionários podem ser utilizados para definição de parâmetros dentro de funções."
  },
  {
    "objectID": "basicos/0103exibição.html#funções-de-plotagem",
    "href": "basicos/0103exibição.html#funções-de-plotagem",
    "title": "Exibição de imagens",
    "section": "Funções de plotagem",
    "text": "Funções de plotagem\nFinalmente, podemos centralizar o mapa na região de interesse usando a função Map.centerObject e adicionar a imagem usando a função Map.addLayer que tem como parâmetros a imagem a ser exibida, os parâmetros de visualização e um nome para exibição na legenda. Juntando tudo até agora, temos o código a seguir:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar landsatRGB = landsat.select(['SR_B2', 'SR_B3', 'SR_B4']);\n\nvar landsat_primeira_julho = landsatRGB.first().multiply(0.0000275).add(-0.2);\n\nvar visualizacao = {\n  bands: ['SR_B4', 'SR_B3', 'SR_B2'],\n  min: 0.01,\n  max: 0.2,\n};\n\nMap.centerObject(area)\n\nMap.addLayer(landsat_primeira_julho, visualizacao, 'Composição RGB Verdadeira');\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nSe não tiver certeza de valores para os parâmetros min e max de visualização, clique nas opções da camada no painel do mapa e selecione uma das opções valor automático, por exemplo a opção Stretch: 98%:\n\n\n\n\n\nInsira os valores calculados automaticamente nas variáveis para mante-los na próxima vez que executar o código."
  },
  {
    "objectID": "basicos/0101interface.html",
    "href": "basicos/0101interface.html",
    "title": "A interface web da plataforma GEE",
    "section": "",
    "text": "Ao acessar o link https://code.earthengine.google.com/ o usuário terá acesso ao ambiente web da plataforma Earth Engine. A interface é composta de 4 painéis principais e um campo de busca:\n\n\n\n\n\n\nCampo de busca: aqui você poderá buscar coleções de imagens, funções e localizações no mapa.\nPainel de navegação: é aqui onde o usuário organiza suas pastas e arquivos (aba Scripts). A aba Docs disponibiliza acesso rápido à documentação de funções da plataforma. Na aba Assets o usuário pode fazer o upload de imagens e outros dados de produção própria como shapefiles.\nEditor de código: é neste painel onde é escrito o código que deverá ser executado, e isto pode ser feito pressionando o botão Run.\nConsole: a aba Console mostra resultados ao utilizar a função print. A aba Inspector mostra valores inspecionados ao clicar nas camadas disponíveis no mapa. A aba Task mostra tarefas executadas tais como exportações de imagens, tabelas e shapefiles.\nVisualizador de mapa: aqui são produzidas as imagens ao utilizar as funções relacionadas à plotagem de imagens e mapas. É neste painel também onde o usuário pode produzir vetores utilizando as ferramentas disponíveis no canto superior esquerdo."
  },
  {
    "objectID": "basicos/0101interface.html#a-interface",
    "href": "basicos/0101interface.html#a-interface",
    "title": "A interface web da plataforma GEE",
    "section": "",
    "text": "Ao acessar o link https://code.earthengine.google.com/ o usuário terá acesso ao ambiente web da plataforma Earth Engine. A interface é composta de 4 painéis principais e um campo de busca:\n\n\n\n\n\n\nCampo de busca: aqui você poderá buscar coleções de imagens, funções e localizações no mapa.\nPainel de navegação: é aqui onde o usuário organiza suas pastas e arquivos (aba Scripts). A aba Docs disponibiliza acesso rápido à documentação de funções da plataforma. Na aba Assets o usuário pode fazer o upload de imagens e outros dados de produção própria como shapefiles.\nEditor de código: é neste painel onde é escrito o código que deverá ser executado, e isto pode ser feito pressionando o botão Run.\nConsole: a aba Console mostra resultados ao utilizar a função print. A aba Inspector mostra valores inspecionados ao clicar nas camadas disponíveis no mapa. A aba Task mostra tarefas executadas tais como exportações de imagens, tabelas e shapefiles.\nVisualizador de mapa: aqui são produzidas as imagens ao utilizar as funções relacionadas à plotagem de imagens e mapas. É neste painel também onde o usuário pode produzir vetores utilizando as ferramentas disponíveis no canto superior esquerdo."
  },
  {
    "objectID": "basicos/0101interface.html#criando-pastas-e-scripts",
    "href": "basicos/0101interface.html#criando-pastas-e-scripts",
    "title": "A interface web da plataforma GEE",
    "section": "Criando pastas e scripts",
    "text": "Criando pastas e scripts\nA interface web normalmente se inicia com um novo script em branco. Após preencher este arquivo de qualquer maneira você poderá salva-lo pressionando o botão Save na parte superior direita do editor de código. O menu que irá aparecer permite a escolha do repositório e pasta na qual o arquivo deverá ser salvo.\nAmbientes de trabalho no ambiente web da plataforma Earth Engine são divididos em repositórios, que por sua vez podem ou não ser subdivididos em pastas:\n\n\n\n\n\nPara criar novos repositórios, pastas ou arquivos, pressione o botão NEW na parte superior direita do painel de navegação:"
  },
  {
    "objectID": "basicos/0101interface.html#executando-seus-scripts",
    "href": "basicos/0101interface.html#executando-seus-scripts",
    "title": "A interface web da plataforma GEE",
    "section": "Executando seus scripts",
    "text": "Executando seus scripts\nPara que qualquer código escrito no editor de código tome efeito e seja executado, você deverá pressionar o botão Run na parte superior direita do painel do editor de código:"
  },
  {
    "objectID": "basicos/0102coleção.html",
    "href": "basicos/0102coleção.html",
    "title": "Definição da coleção e filtros básicos",
    "section": "",
    "text": "O primeiro passo para trabalhar com a plataforma Earth Engine é a definição de uma (ou mais) coleção de interesse. Uma lista completa de todas as coleções disponíveis na plataforma Earth Engine está disponível no link https://developers.google.com/earth-engine/datasets/catalog. Também estão disponíveis catálogos específicos para imagens Landsat, MODIS e Sentinel. Você também pode utilizar a barra de busca acima do editor de código para buscar coleções de interesse:"
  },
  {
    "objectID": "basicos/0102coleção.html#consultando-o-catálogo-de-imagens",
    "href": "basicos/0102coleção.html#consultando-o-catálogo-de-imagens",
    "title": "Definição da coleção e filtros básicos",
    "section": "",
    "text": "O primeiro passo para trabalhar com a plataforma Earth Engine é a definição de uma (ou mais) coleção de interesse. Uma lista completa de todas as coleções disponíveis na plataforma Earth Engine está disponível no link https://developers.google.com/earth-engine/datasets/catalog. Também estão disponíveis catálogos específicos para imagens Landsat, MODIS e Sentinel. Você também pode utilizar a barra de busca acima do editor de código para buscar coleções de interesse:"
  },
  {
    "objectID": "basicos/0102coleção.html#definindo-a-coleção-no-código",
    "href": "basicos/0102coleção.html#definindo-a-coleção-no-código",
    "title": "Definição da coleção e filtros básicos",
    "section": "Definindo a coleção no código",
    "text": "Definindo a coleção no código\nPodemos então definir nossa coleção através da função ee.ImageCollection que aceita como argumento o código referente à coleção de interesse. O exemplo a seguir mostra a definição da coleção utilizando imagens Landsat 8 corrigidas com valores de reflectância da superfície terrestre, referenciada pelo código 'LANDSAT/LC08/C02/T2_L2'. Link para a coleção.\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2');\n\n\n\n\n\n\nDefinição de variáveis e objetos\n\n\n\n\n\nPor utilizar a linguagem de programação javascript, a definição de novas variáveis ou objetos na plataforma Earth Engine sempre se precederá do comando var:\n// Exemplo\nvar a = 2;\nvar b = 3;\nvar c = a + b;\nprint(c)"
  },
  {
    "objectID": "basicos/0102coleção.html#filtro-temporal-e-espacial",
    "href": "basicos/0102coleção.html#filtro-temporal-e-espacial",
    "title": "Definição da coleção e filtros básicos",
    "section": "Filtro temporal e espacial",
    "text": "Filtro temporal e espacial\nCertamente não há necessidade de utilizar todas as imagens na coleção, portanto é importante definir uma faixa temporal e uma região de interesse. Utilize a ferramenta de retângulo no painel do mapa e escolha uma área de interesse. Neste caso delimitou-se a região do Parque Nacional de Brasília:\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nVocê pode esconder a geometria no painel do mapa e ela continuará funcionando nas funções.\n\n\nNote que isto criou uma geometria nova no painel de edição de código chamada “geometry”. Você pode renomear esta geometria clicando no seu nome:\n\n\n\n\n\nAgora podemos filtrar a coleção com base na região definida utilizando a função filterBounds que tem como argumento a área limite:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(area)\nEm seguida, podemos filtrar a coleção por faixa temporal usando a função filterDate que tem como argumentos a data inicial e a data final. Como exemplo, vamos escolher imagens apenas no mês de julho de 2023.\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(area).filterDate(\"2021-07-01\", \"2021-07-31\");\nprint(landsat)\nAo pressionar o botão Run utilizando o código anterior, você poderá ver os detalhes da coleção no console. Observe que a coleção agora contem somente 2 imagens:\n\n\n\n\n\n\n\n\n\n\n\nObservação\n\n\n\nNa maioria das vezes você verá o código distribuído verticalmente:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nprint(landsat)\nO código é essencialmente o mesmo, porém muitos optam pela distribuição vertical por questão de legibilidade.\n\n\n\n\n\n\n\n\nAplicando funções a objetos\n\n\n\n\n\nNote que funções são aplicadas de maneira subsequente utilizando o ponto (.), que é o modo como as funções são concatenadas uma atrás da outra (se o objeto gerado permitir a aplicação da função). Por exemplo, o código:\nee.ImageCollection('LANDSAT/LC08/C02/T1_L2').filterBounds(area)\npode ser lido como “acesse o objeto ee (a base Earth Engine), aplique a função ImageCollection com o argumento 'LANDSAT/LC08/C02/T1_L2' e em seguida aplique a função FilterBounds com o argumento area”."
  },
  {
    "objectID": "basicos/0102coleção.html#consultando-metadados-das-coleções",
    "href": "basicos/0102coleção.html#consultando-metadados-das-coleções",
    "title": "Definição da coleção e filtros básicos",
    "section": "Consultando metadados das coleções",
    "text": "Consultando metadados das coleções\nAntes de continuar, é importante demonstrar como lidar com os detalhes específicos das coleções disponíveis na plataforma. Continuando com imagens Landsat 8 como exemplo, acesse o link da coleção e observe o painel logo abaixo do cabeçalho. Este painel contém informações importantes sobre a aquisição, pré-processamento e detalhes sobre o formato das imagens. A aba Description, por exemplo, contém as informações gerais sobre a coleção.\nA aba Bands descreve as bandas em detalhes, incluindo seus nomes (importante para selecionar bandas específicas). Esta aba é extremamente importante para a visualização e o processamento das imagens. Para economizar espaço de armazenamento, as imagens na plataforma geralmente são salvas em formatos contendo somente números inteiros (Int) e portanto passam por um pré-processamento para ajustar os valores. As bandas 1 a 7 das imagens Landsat 8, por exemplo, tem seus valores entre 1 e 65455 (Int16).\n\n\n\n\n\nPara transformar estes valores para valores reais de reflectância, precisamos multiplicar as imagens pelo valor da coluna Scale e adicionar o valor da coluna Offset. Neste caso, portanto:\n\\[\n\\text{Valor Real} = \\text{Número Digital} \\times \\text{Scale} + \\text{Offset}\n\\] Note que no caso das bandas termais estes valores são diferentes e que nem sempre o valor de Offset existe. É importante consultar esta aba antes de processar a coleção de interesse.\nA aba Image Properties deste painel contem propriedades importantes especificas para cada imagem em uma coleção tal como valores de Path e Row, nível de processamento, etc. A propriedade CLOUD_COVER, por exemplo, descreve a porcentagem de cobertura de nuvens observada em cada imagem, permitindo filtrar uma coleção para conter somente imagens com baixa presença de nuvens. Veremos como fazer isto em tópicos intermediários."
  },
  {
    "objectID": "basicos/0104exercicio1.html",
    "href": "basicos/0104exercicio1.html",
    "title": "Exercício 1 - Coleção Sentinel 2",
    "section": "",
    "text": "Repita os passos das seções anteriores mas desta vez adicione uma imagem da coleção Sentinel 2 ao mapa em uma composição com suas cores verdadeiras.\n\n\n\n\n\n\nResposta\n\n\n\n\n\nO código da coleção Sentinel 2 é COPERNICUS/S2_HARMONIZED ou COPERNICUS/S2_SR_HARMONIZED (correção atmosférica). O fator multiplicativo das imagens é de 0.0001. Os nomes das bandas correspondentes às cores vermelha, verde e azul são B4, B3 e B2 respectivamente. Uma possível resposta é, portanto:\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') // Ou 'COPERNICUS/S2_HARMONIZED'\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar sentinel_primeira_julho = sentinel.first().multiply(0.0001);\n\nvar visualizacaoRGB = {\n  bands: ['B4', 'B3', 'B2'],\n  min: 0.01,\n  max: 0.2,\n};\n\nMap.centerObject(area)\n\nMap.addLayer(sentinel_primeira_julho, visualizacaoRGB, 'Composição RGB Verdadeira');"
  },
  {
    "objectID": "basicos/0104exercicio1.html#exercício-1a",
    "href": "basicos/0104exercicio1.html#exercício-1a",
    "title": "Exercício 1 - Coleção Sentinel 2",
    "section": "",
    "text": "Repita os passos das seções anteriores mas desta vez adicione uma imagem da coleção Sentinel 2 ao mapa em uma composição com suas cores verdadeiras.\n\n\n\n\n\n\nResposta\n\n\n\n\n\nO código da coleção Sentinel 2 é COPERNICUS/S2_HARMONIZED ou COPERNICUS/S2_SR_HARMONIZED (correção atmosférica). O fator multiplicativo das imagens é de 0.0001. Os nomes das bandas correspondentes às cores vermelha, verde e azul são B4, B3 e B2 respectivamente. Uma possível resposta é, portanto:\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') // Ou 'COPERNICUS/S2_HARMONIZED'\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar sentinel_primeira_julho = sentinel.first().multiply(0.0001);\n\nvar visualizacaoRGB = {\n  bands: ['B4', 'B3', 'B2'],\n  min: 0.01,\n  max: 0.2,\n};\n\nMap.centerObject(area)\n\nMap.addLayer(sentinel_primeira_julho, visualizacaoRGB, 'Composição RGB Verdadeira');"
  },
  {
    "objectID": "basicos/0104exercicio1.html#exercício-1b",
    "href": "basicos/0104exercicio1.html#exercício-1b",
    "title": "Exercício 1 - Coleção Sentinel 2",
    "section": "Exercício 1B",
    "text": "Exercício 1B\nA composição RGB utilizando as bandas do infravermelho de bandas curtas (SWIR), do infravermelho próximo (NIR) e do vermelho é útil para ressaltar a vegetação em imagens de satélite. Dito isso, repita o exercício anterior mas adicione também uma imagem usando a composição mencionada, prestando atenção nos valores mínimos e máximos.\n\n\n\n\n\n\nResposta\n\n\n\n\n\nAs bandas SWIR, NIR e vermelho das imagens Sentinel 2 recebem os nomes B11, B8 e B4 respectivamente, portanto uma possível resposta seria:\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') // Ou 'COPERNICUS/S2_HARMONIZED'\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n              \nvar sentinel_primeira_julho = sentinel.first().multiply(0.0001);\n\nvar visualizacaoRGB = {\n  bands: ['B4', 'B3', 'B2'],\n  min: 0.01,\n  max: 0.2,\n};\n\nvar visualizacaoVeg = {\n  bands: ['B11', 'B8', 'B4'],\n  min: 0.01,\n  max: 0.3,\n};\n\nMap.centerObject(area)\n\nMap.addLayer(sentinel_primeira_julho, visualizacaoRGB, 'Composição RGB Verdadeira');\nMap.addLayer(sentinel_primeira_julho, visualizacaoVeg, 'Composição RGB Falsa (SWIR/NIR/Red)');"
  },
  {
    "objectID": "basicos/0105funções.html",
    "href": "basicos/0105funções.html",
    "title": "Criando suas próprias funções",
    "section": "",
    "text": "Vimos como calcular o NDVI de uma imagem Landsat 8 na seção anterior:\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red))\nPorém, se fossemos calcular o NDVI para varias imagens, acumularíamos mais e mais linhas de código similares, possivelmente levando a confusões:\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red));\n\nvar red2 = img2.select('SR_B4');\nvar nir2 = img2.select('SR_B5');\n\nvar ndvi2 = nir2.subtract(red2).divide(nir2.add(red2));\n\nvar red3 = img3.select('SR_B4');\nvar nir3 = img3.select('SR_B5');\n\nvar ndvi3 = nir3.subtract(red3).divide(nir3.add(red3));\n\n//Etc..."
  },
  {
    "objectID": "basicos/0105funções.html#o-problema",
    "href": "basicos/0105funções.html#o-problema",
    "title": "Criando suas próprias funções",
    "section": "",
    "text": "Vimos como calcular o NDVI de uma imagem Landsat 8 na seção anterior:\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red))\nPorém, se fossemos calcular o NDVI para varias imagens, acumularíamos mais e mais linhas de código similares, possivelmente levando a confusões:\nvar red = img.select('SR_B4');\nvar nir = img.select('SR_B5');\n\nvar ndvi = nir.subtract(red).divide(nir.add(red));\n\nvar red2 = img2.select('SR_B4');\nvar nir2 = img2.select('SR_B5');\n\nvar ndvi2 = nir2.subtract(red2).divide(nir2.add(red2));\n\nvar red3 = img3.select('SR_B4');\nvar nir3 = img3.select('SR_B5');\n\nvar ndvi3 = nir3.subtract(red3).divide(nir3.add(red3));\n\n//Etc..."
  },
  {
    "objectID": "basicos/0105funções.html#a-solução",
    "href": "basicos/0105funções.html#a-solução",
    "title": "Criando suas próprias funções",
    "section": "A solução",
    "text": "A solução\nPodemos resolver o problema e manter o código mais conciso criando nossa própria função de cálculo do NDVI. Funções são como máquinas que recebem um objeto, realizam um processamento e retornam outro objeto de interesse. Funções são bastante uteis quando se pretende aplicar um mesmo processo a diversas imagens. Traduzindo o processo de cálculo do NDVI para uma função, temos o seguinte:\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  \n  return ndvi;\n}\nNote que neste caso não precisamos usar o comando var. O código acima cria uma função chamada calcular_ndvi que recebe uma imagem, extrai as bandas vermelho e NIR e por fim calcula e retorna a imagem NDVI. Usando ela no bloco de código anterior, teríamos o seguinte:\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  \n  return ndvi;\n}\n\nvar ndvi1 = calcular_ndvi(img1);\nvar ndvi2 = calcular_ndvi(img2);\nvar ndvi3 = calcular_ndvi(img3);\nTambém podemos criar uma função para corrigir os valores das imagens Landsat para os valores reais como visto anteriormente:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nvar corrigida = corrigir_valores(img)\nFunções são extremamente uteis no contexto da plataforma Earth Engine e podem ser aplicadas a coleções inteiras, como se verá na seção seguinte."
  },
  {
    "objectID": "basicos/0107reduções.html",
    "href": "basicos/0107reduções.html",
    "title": "Reduções de coleções",
    "section": "",
    "text": "Suponha agora que precisamos calcular alguma estatística entre diversas imagens. Para isto, podemos utilizar as funções da plataforma Earth Engine conhecidas como reducers, ou seja, funções que “reduzem” um grupo de imagens a uma (ou mais) imagem representando um tipo de dado desejado. Uma destas funções é a função mean, que extrai a média de um grupo de imagens. Como exemplo, vejamos como extrair o NDVI médio em um mês:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\nEste é o mesmo código utilizado na seção anterior. Para calcular a média dos valores de NDVI entre as duas imagens disponíveis basta aplicar a função mean sem nenhum parâmetro:\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\nObserve como a coleção foi transformada em uma única imagem:\n\n\n\n\n\nE para adicioná-la ao mapa o processo é o mesmo já visto:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndvi_julho_media, visNDVI, 'NDVI Médio em Julho');\nA tabela a seguir mostra alguns exemplos de funções de redução mais simples que devem cobrir grande parte dos casos de uso:\n\n\n\n\n\nFunção\nResultado\n\n\n\n\nmean\nValor médio entre imagens\n\n\nmax\nValor máximo dentre as imagens\n\n\nmin\nValor mínimo dentre as imagens\n\n\nmedian\nValor mediano entre as imagens\n\n\nmode\nValor mais comum (moda) dentre as imagens\n\n\n\n\nAlém destas funções, a plataforma conta com outros tipos de funções de redução mais específicos que podem ser acessados através do objeto ee.Reducer e aplicados usando a função geral reduce. Por exemplo, para extrair o desvio padrão dos valores de NDVI em julho, o código seria o seguinte:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar ndvi_julho_desvpad = ndvi_julho.reduce(ee.Reducer.stdDev())\nUma lista completa das funções de redução disponíveis dentro do objeto ee.Reducer pode ser consultada neste link sob a seção ee.Reducer em Client Libraries."
  },
  {
    "objectID": "basicos/0108export.html",
    "href": "basicos/0108export.html",
    "title": "Exportando imagens e vetores",
    "section": "",
    "text": "Agora que cobrimos a maior parte dos conceitos básicos da plataforma Earth Engine, resta aprender como exportar as imagens processadas. Apesar de ser uma ferramenta útil para exportar imagens base, é importante lembrar que a filosofia de uso da plataforma é a de que deve se buscar utiliza-la para todo ou a maior parte do processamento e exportar somente o produto final.\nNesta seção veremos como exportar as imagens para o seu Google Drive, porém também é possível exporta-las para a plataforma Google Cloud ou então como um item na sua própria biblioteca do Earth Engine (aba Assets no painel de navegação).\nRetornando à seção anterior onde fizemos o cálculo do NDVI do mês de julho, temos o seguinte código:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndvi_julho_media, visNDVI, 'NDVI Médio em Julho');\nSuponha que desejamos exportar esta imagem com o NDVI médio. Para isto, usamos a função Export.image.toDrive, que precisa de alguns parâmetros específicos. O código a seguir mostra os parâmetros mais importantes, mas não todos (os demais parâmetros podem ser consultados neste link).\nExport.image.toDrive({\n  image: , // Qual objeto exportar\n  description: , // Identificador da tarefa de exportação\n  folder: , // Em qual pasta do drive exportar (se desejar uma pasta específica)\n  crs: , // Código CRS do sistema de coordenadas desejado para a imagem exportada\n  region: , // Área de recorte da imagem (se existir)\n  scale: // Resolução da imagem\n});\n\n\n\n\n\n\nConsultando o código CRS\n\n\n\n\n\nO código identificador do sistema de coordenadas desejado pode ser consultado em sites como https://epsg.io/. Programas como o ArcGIS e QGIS também podem ser consultados.\n\n\n\nAplicando isto ao nosso código anterior, temos então o seguinte exemplo:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndvi_julho_media, visNDVI, 'NDVI Médio em Julho');\n\nExport.image.toDrive({\n  image: ndvi_julho_media,\n  description: 'ndvi_medio_julho_2021',\n  folder: 'Earth Engine',\n  crs: 'EPSG:5880', // Projeção SIRGAS policônica\n  region: area, \n  scale: 30\n});\nApós pressionar o botão Run, o código será executado e você poderá observar que a tarefa de exportação foi adicionada à aba Tasks no painel do console:\n\n\n\n\n\nAo pressionar o botão azul RUN à direita da tarefa, você poderá confirmar os parâmetros e finalmente confirmar a exportação:"
  },
  {
    "objectID": "basicos/0108export.html#exportando-imagens",
    "href": "basicos/0108export.html#exportando-imagens",
    "title": "Exportando imagens e vetores",
    "section": "",
    "text": "Agora que cobrimos a maior parte dos conceitos básicos da plataforma Earth Engine, resta aprender como exportar as imagens processadas. Apesar de ser uma ferramenta útil para exportar imagens base, é importante lembrar que a filosofia de uso da plataforma é a de que deve se buscar utiliza-la para todo ou a maior parte do processamento e exportar somente o produto final.\nNesta seção veremos como exportar as imagens para o seu Google Drive, porém também é possível exporta-las para a plataforma Google Cloud ou então como um item na sua própria biblioteca do Earth Engine (aba Assets no painel de navegação).\nRetornando à seção anterior onde fizemos o cálculo do NDVI do mês de julho, temos o seguinte código:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndvi_julho_media, visNDVI, 'NDVI Médio em Julho');\nSuponha que desejamos exportar esta imagem com o NDVI médio. Para isto, usamos a função Export.image.toDrive, que precisa de alguns parâmetros específicos. O código a seguir mostra os parâmetros mais importantes, mas não todos (os demais parâmetros podem ser consultados neste link).\nExport.image.toDrive({\n  image: , // Qual objeto exportar\n  description: , // Identificador da tarefa de exportação\n  folder: , // Em qual pasta do drive exportar (se desejar uma pasta específica)\n  crs: , // Código CRS do sistema de coordenadas desejado para a imagem exportada\n  region: , // Área de recorte da imagem (se existir)\n  scale: // Resolução da imagem\n});\n\n\n\n\n\n\nConsultando o código CRS\n\n\n\n\n\nO código identificador do sistema de coordenadas desejado pode ser consultado em sites como https://epsg.io/. Programas como o ArcGIS e QGIS também podem ser consultados.\n\n\n\nAplicando isto ao nosso código anterior, temos então o seguinte exemplo:\nfunction corrigir_valores(imagem){\n  return imagem.multiply(2.75e-5).add(-0.2)\n}\n\nfunction calcular_ndvi(imagem){\n  var red = imagem.select('SR_B4');\n  var nir = imagem.select('SR_B5');\n  var ndvi = nir.subtract(red).divide(nir.add(red));\n  return ndvi;\n}\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-07-01\", \"2021-07-31\");\n\nvar ndvi_julho = landsat.map(corrigir_valores).map(calcular_ndvi)\nprint(ndvi_julho)\n\nvar ndvi_julho_media = ndvi_julho.mean()\nprint(ndvi_julho_media)\n\nvar visNDVI = {\n  min: 0,\n  max: 1,\n  palette: ['red', 'white', 'green']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndvi_julho_media, visNDVI, 'NDVI Médio em Julho');\n\nExport.image.toDrive({\n  image: ndvi_julho_media,\n  description: 'ndvi_medio_julho_2021',\n  folder: 'Earth Engine',\n  crs: 'EPSG:5880', // Projeção SIRGAS policônica\n  region: area, \n  scale: 30\n});\nApós pressionar o botão Run, o código será executado e você poderá observar que a tarefa de exportação foi adicionada à aba Tasks no painel do console:\n\n\n\n\n\nAo pressionar o botão azul RUN à direita da tarefa, você poderá confirmar os parâmetros e finalmente confirmar a exportação:"
  },
  {
    "objectID": "basicos/0108export.html#exportando-vetores",
    "href": "basicos/0108export.html#exportando-vetores",
    "title": "Exportando imagens e vetores",
    "section": "Exportando vetores",
    "text": "Exportando vetores\nO processo para exportação de vetores é similar e pode ser feito utilizando a função Export.table.toDrive. Supondo que desejamos exportar a nossa área limite definida no inicio deste tutorial, o código é o seguinte:\nExport.table.toDrive({\n  collection: area,\n  description: 'parque_nacional_brasilia',\n  folder: 'Earth Engine'\n});\nAo confirmar a tarefa, você poderá definir o tipo de arquivo para qual exportar seus vetores tais como SHP, CSV e KMZ:"
  },
  {
    "objectID": "intermediarios/0201filtros.html",
    "href": "intermediarios/0201filtros.html",
    "title": "Filtrando propriedades",
    "section": "",
    "text": "Já sabemos como filtrar imagens de maneira básica definindo limites temporais e espaciais, mas e nos casos em que se deseja filtrá-las em função de parâmetros específicos como a porcentagem de cobertura de nuvens, número de órbitas e/ou número de linhas?\nPara isso, podemos empregar as funções da família ee.Filter. Essas funções permitem que argumentos lógicos sejam utilizados para filtrar imagens dentro de uma coleção. A tabela a seguir mostra alguns exemplos comuns dentre essas funções:\n\n\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nee.Filter.eq\nRetorna somente imagens com atributo igual ao especificado\n\n\nee.Filter.neq\nRetorna somente imagens com atributo diferente do especificado\n\n\nee.Filter.lt\nRetorna somente imagens com atributo de valor inferior ao especificado\n\n\nee.Filter.gt\nRetorna somente imagens com atributo de valor superior ao especificado\n\n\nee.Filter.listContains\nRetorna imagens que contenham o valor especificado dentro do atributo de interesse\n\n\nee.Filter.date\nSimilar à função filterDate, porém permite que você crie um filtro reutilizável\n\n\n\nA lista completa de funções para filtragem pode ser consultada neste link, mas as funções acima cobrem a maior parte dos usos.\nSe, por exemplo, desejássemos filtrar nossa coleção Landsat dos exemplos anteriores para conter somente imagens com baixa porcentagem de nuvens, poderíamos faze-lo aplicando a função ee.Filter.lt ao parâmetro interno CLOUD_COVER:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-01-01\", \"2021-12-31\");\n\nvar landsatFiltrada = landsat.filter(ee.Filter.lt('CLOUD_COVER', 20))\n              \nprint(\"Número de imagens na coleção:\", landsat.size())\nprint(\"Número de imagens na coleção filtrada:\", landsatFiltrada.size())\nNesse exemplo, permitimos somente imagens com valores de cobertura de nuvens inferiores a 20%. Observe a diferença entre o número de imagens na coleção original e na coleção filtrada:\n\n\n\n\n\nPergunta: o que aconteceria se utilizássemos a função ee.Filter.eq no lugar da função ee.Filter.lt?\n\n\n\n\n\n\nResposta\n\n\n\n\n\nNesse caso só seriam permitidas imagens com valor de porcentagem de cobertura igual a 20%.\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-01-01\", \"2021-12-31\");\n\nvar landsatFiltrada = landsat.filter(ee.Filter.eq('CLOUD_COVER', 20))\n              \nprint(\"Número de imagens na coleção:\", landsat.size())\nprint(\"Número de imagens na coleção filtrada:\", landsatFiltrada.size())\nNo caso da nossa coleção, nenhuma das imagens é compatível com o critério:\n\nNúmero de imagens na coleção:\n21\nNúmero de imagens na coleção filtrada:\n0\n\n\n\n\nÉ importante mencionar que os filtros ee.Filter podem ser criados como variáveis isoladas e podem ser reutilizados. Observe o caso a seguir utilizando a função ee.Filter.date:\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filterDate(\"2021-01-01\", \"2021-12-31\");\n\nvar primeiro_semestre = ee.Filter.date('2021-01-01', '2021-06-30');\nvar segundo_semestre = ee.Filter.date('2021-07-01', '2021-12-31');\n\nvar landsat_primeiro_semestre = landsat.filter(primeiro_semestre);\nvar landsat_segundo_semestre = landsat.filter(segundo_semestre);\n\nprint('Total de imagens no primeiro semestre:', landsat_primeiro_semestre.size())\nprint('Total de imagens no segundo semestre:', landsat_segundo_semestre.size())\n\nTotal de imagens no primeiro semestre:\n9\nTotal de imagens no segundo semestre:\n12\n\nEsse conhecimento é útil em casos que você sabe que irá reutilizar o mesmo filtro múltiplas vezes ou se você deseja aplicar mais de um filtro a uma coleção sem ter que modificá-la."
  },
  {
    "objectID": "intermediarios/0203exercicio3.html",
    "href": "intermediarios/0203exercicio3.html",
    "title": "Exercício 3 - Máscara com NDWI",
    "section": "",
    "text": "Utilizando todo o conhecimento adquirido até agora e a fórmula vista no Exercício 2, crie uma máscara de corpos d’água com base em um valor de corte do NDWI médio do ano de 2021. Além de definir 2021 como o ano de interesse, filtre a coleção para conter somente imagens com baixa cobertura de nuvens (&lt;5%).\n\n\n\n\n\n\nResposta\n\n\n\n\n\nAplicando tudo que vimos até agora, o processo é o seguinte:\n\nDefinição de uma função para corrigir as imagens e calcular o NDWI\nDefinir a coleção base, seus limites temporais e espaciais, e filtrar as imagens com alta frequência de nuvens\nAplicar a função de cálculo do NDWI à coleção usando a função map e em seguida extrair a média da coleção usando a função mean\nDefinir um valor de corte do NDWI (por exemplo 0.2) para extrair a máscara d’água\nPlotar os resultados\n\n// 1. Função de correção e cálculo do NDWI\nfunction calcular_ndwi(imagem){\n  imagem = imagem.multiply(2.75e-05).add(-0.2);\n  var green = imagem.select('SR_B3');\n  var nir = imagem.select('SR_B5');\n  var ndwi = green.subtract(nir).divide(green.add(nir));\n  return ndwi;\n}\n\n// 2. Coleção base e filtros\nvar ano_2021 = ee.Filter.date(\"2021-01-01\", \"2021-12-31\");\n\nvar landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')\n              .filterBounds(area)\n              .filter(ano_2021)\n              .filter(ee.Filter.lt('CLOUD_COVER', 5));\n\n// 3. Funções map e mean\nvar ndwi_2021 = landsat.map(calcular_ndwi).mean();\n\n// 4. Extração da máscara\nvar mascara_agua = ndwi_2021.gt(0.2).selfMask();\n\n// 5. Plotagem\nvar visNDWI = {\n  min: -1,\n  max: 1,\n  palette: ['gray', 'white', 'blue']\n};\n\nMap.centerObject(area);\nMap.addLayer(ndwi_2021, visNDWI, 'NDWI Médio de 2021');\nMap.addLayer(mascara_agua, {palette:['blue']}, 'Máscara Água 2021');"
  }
]